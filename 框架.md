# 关于框架
## Vue 相关
> ### Vue 生命周期
- 所有的生命周期包含beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed
- beforeCreate 和created 之间完成的是初始化事件和数据的观测，此时还没有el 选项
- created 和beforeMount 之间会判断是否有el 选项，如果有则向下编译，如果没有则等待vm.$mount(el)
- beforeMound 和mounted 之间给vue 实例对象添加$el 成员
- mounted 完成模板中的html渲染到html页面中，此过程中进行ajax交互。
- 数据改变会触发beforeUpdate 和updated 事件
- beforeDestroy 和destroyed 在实例销毁时调用，在beforeDestroy 时，实例是完全可用的
- 参考链接：https://segmentfault.com/a/1190000011381906

> ### Vue.nextTick
- 官方文档：在下次DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
- 什么意思呢？就是说在js 中改变变量的值以后，dom 并不会立即更新，变量值的改变与dom 的更新是异步操作，所以dom 的更新会有延时。如果我想在变量改变后立刻去操作dom 那就需要使用nextTick 方法。因为nextTick 是发生在dom 更新以后的。
- 参考：https://segmentfault.com/a/1190000012861862

> ### Vue.$set
- 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。
- 也就是说新添加的属性没有执行双向绑定操作，如果想要实现双向绑定，就需要使用Vue.$set 进行设置。

> ### Vue 路由实现
- hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。
- history 模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。

> ### Vuex 是什么？
是同级组件传值的一种机制，包含以下几个概念：
- state：相当于全局变量
- getters：获取变量属性值
- mutations：修改变量的方法
- action：同mutations 类似，可以对变量进行修改，不过是异步操作
- modules：项目复杂的时候用来进行模块管理

> ### keep-alive
- keep-alive是 Vue 内置的一个组件，可以使被包含的组件被缓存
- 在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子: activated 与 deactivated
    - activated 在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用
    - deactivated：组件被停用(离开路由)时调用
- 使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了


---
## Angular 相关
### 