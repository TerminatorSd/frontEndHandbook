## 修改软件的艺术：构建易维护代码的9条最佳实践

### 软件与硬件
- 我们称硬件为“硬”是因为他是固定的，没有工具是无法调整的
- 讽刺的是，作为软件的代码，在编程完成脱离开发者之后变得比硬件还难修改；开发者编写的代码无法修改是再常见不过的了

### 软件维护成本很高
- 修复bug往往很快变成打地鼠一样的体验，一个看似简单只需要几分钟修复的问题可能为系统带来无穷无尽的修改
- 维护软件时期的花费可能比开发时期的花费高出5倍之多

### 混乱报告
- 混轮报告是斯坦迪什咨询集团针对软件开放行业做的一项研究报告
- 报告指出：45%的功能从未被使用过

### 瀑布模型
- 存在的问题
    - 先部分后整体的方式在虚拟世界并不奏效，并不是因为这种方式效率低下，而是因为它让我们建造出来的东西难以改变
    - 刺激与反馈，要尽可能紧密结合以便改变我们的习惯，当开发者直到几个月之后才看到行为结果，他已经变得不完全合适了。就像我们的人生座右铭：找出错误并非我的工作；创造错误才是

### 代码应该是自解释的
- 自解释 = 测试 + 优秀命名 + 通行用法
- 注释为什么，而不是怎么做

### 未知是难以量化的
- 软件开发行业充满了大量的未知，所以我们需要在度量方面下功夫，度量什么，如何度量
- 软件的浪费是所有已经开展但尚未完成的任务，是半成品（WIP）

### 技术采用周期
- 创新者、早期实践者、多数派先行者、多数派后行者、滞后者
- 从创新者发展到早期实践者的过程称之为“跨越鸿沟”

### 开发者的基本素养
- 并不是说开发者不能时不时地做出一些短期的妥协，而是当他们作出妥协时清楚地知道，每次他们回头面对糟糕的代码时要付出的代价

### 原则
- 比如单一职责原则、开闭原则
- 原则只告诉你要做什么，但是没有告诉你怎么做

### 共识
- 你听到那个总结然后用你特定的方式理解。最后我们从两个不同的主观理解出发以为有了共识，但是他们可能完完全全不同。
- 验收的标准是什么？验收测试，要讲清楚快乐路径、次要路径、异常路径和错误路径下的表现；用户故事和验收标准应该是产品经理的事情。验收测试回答了这个问题：我怎么知道什么时候算做完了？
- 事先准备的对话，不准备，大多数时候会变成信息密度极低的讨论

### 角色
- 产品负责人：PO or PD，对项目全权负责，跟用户频繁互动，对产品理解最深刻，灵魂人物
- Scrum Master，监督纪律的执行和共识的遵守

### 好代码的标准是什么
- 容易阅读、效率高、性能好、圈复杂度低
- CLEAN: Cohesive、Loosely Coupled、Encapsulated、Assertive、Nonredundant。内聚、松散耦合（设计有意耦合，避免意外耦合）、封装、自主、没有冗余
- 不要有“上帝对象”，之所以叫“上帝对象”不是因为他试图处理所有的事情，而是在试图修改它时，你会惊呼“我的上帝啊”。
- 所有的代码都在同一个抽象层
- Bob 大叔说，理想的方法长度不应该超过四行代码

### 一天实际上之后4个小时的工作时间

### TDD
- 缺乏可测性的系统，往往意味着糟糕的设计
- 测试是传感器，就像你车上的引擎灯一样。他们一直在那，如果新添加的代码让他由绿变红，就是告诉你有些地方出错了。
- 单元测试中的单元是指一个独立的、可验证的行为，他必须对系统产生可观察的影响，而不和系统的其他行为耦合
- 从反馈的角度来看，如果想要“刺激-响应“过程形成持久的精神影响，响应必须紧随刺激。“敲击这根杆，我迟早来喂你”对狗来说没有效果。
- 测试感染者，自然而然已测试先行的方式进行思考
- 因为没有实行测试驱动开发，所以他们没有时间实行测试驱动开发
- 单元测试是活的文档
- 依赖注入使代码更容易测试
- 有人会告诉你TDD 能减少缺陷，但是有成本，你会编写比产品代码多两杯的测试代码，所以会降低速度。这种假设认为影响软件开发的因素是打字速度，但这不是真的，实际上的影响因素是阅读需求文档、编写文档、开会、定位和修复bug

### 用版本库管理一切
- 依赖、构建部署脚本、测试用例

### 流程管理
- 如果在产品代码中频繁出现缺陷，则意味着开发流程可能出问题了，找到问题的根源并且修复它
- 时间盒子搭配spike 使用，在一个固定的时间里，比如说一周或两周，就用来解决一个特定的问题

### 什么是依赖
- 如果你的车因为火花塞不打火而无法启动，但火花塞又是焊上去的，连接着十几个其他组件，而且同时用来支持引擎组件，那么更换火花塞或许还不如换辆新车来得划算。这就是我们所谓的“依赖”。

### 学徒制
- 先学习开车，再去考驾照。没有人（但愿真的没有人）第一次坐到方向盘前面就参加驾照考试。我们要先拿到新手许可，学习交通规则，在空旷的停车场进行练习……
- 每个技能背后都有方法论、技巧、实践和原则，协作也是一样。

### 严重被低估的最佳实践-结对编程
- 极限编程中最有价值同时也是最被轻视和误解的一个实践就是结对编程，结对编程是两个开发者在一台计算机前执行同一项任务。没有比结对编程更能在团队中迅速促进知识和技能的传播的了。
- 让团队新成员和资深开发者（或者至少是有经验的开发者）一起结对一两周。在那段时间里更像是“见习”而非结对编程，资深开发者更多地扮演了导师的角色，而真正理想的结对编程关系则是基于平等的合作关系。餐馆中的服务员就是这么做的，而他们并未肩负百万美元级别的软件项目。
- 驾驶员与领航员模式。驾驶员是键盘前的那个人，领航员坐在他旁边能够清楚地看到整个显示器。驾驶员和领航员应该尽可能频繁地交换角色——多于5分钟但是不超过30分钟。
- 乒乓结对模式，一人写测试，一人做开发，然后互换
- 随机配对可能会带来意外惊喜
- 围攻模式，多人针对一个问题轮番上阵进行编程
- 结对编程的降级方案：在一天的大部分时间里进行日常开发。每天剩余一个小时和伙伴一起对一天的代码进行审查。
- 你至少应该在设计、编码、重构、调试和测试的时候结对

### 领域模型
- 用领域知识搭建出的模型。比如编写一个账务系统，领域模型中的对象应该是账户、资金、余额、支票和财务人员熟悉的其他用语，领域模型应该尽可能地与实现细节分离。

### 重构
- 什么时候应该重构：添加新功能、修复问题、重构比重写的成本低
- 前构：精通重构之后，有趣的事情就会发生，我们不会再写出糟糕的代码或遵循有缺陷的开发实践，从而开始前构
